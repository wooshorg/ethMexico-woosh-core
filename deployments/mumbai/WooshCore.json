{
  "address": "0x0315294DE5e01749c69d2d816964a4F497e62996",
  "abi": [
    {
      "inputs": [],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "StartLoaning",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "StopLoaning",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "AAVE_POOL",
      "outputs": [
        {
          "internalType": "contract IPool",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "ADAI",
      "outputs": [
        {
          "internalType": "contract IERC20",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "DAI",
      "outputs": [
        {
          "internalType": "contract IERC20",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "startloanDAI",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "stopLoanDAI",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x904ac8ed6c0618be2176821eac9f6f213105643d88bfabb5710307146aca3b6f",
  "receipt": {
    "to": null,
    "from": "0x01Cc16b92b9E0Ce88dD7e7A6A90566a6Bbb63a1F",
    "contractAddress": "0x0315294DE5e01749c69d2d816964a4F497e62996",
    "transactionIndex": 3,
    "gasUsed": "311954",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000800020000000000000000100000000004000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000020000000000000080000000000000000000200002000000000000000000000000000000000000000000000000000000004000000000000000000001000000000000000000000000000000100040000000000000000000000000000000000000000000000000000000000000000000100000",
    "blockHash": "0xe38827a8c0724a7706ad77409bc219e7f7bac84041763d7b03eb2be5766a726c",
    "transactionHash": "0x904ac8ed6c0618be2176821eac9f6f213105643d88bfabb5710307146aca3b6f",
    "logs": [
      {
        "transactionIndex": 3,
        "blockNumber": 27709709,
        "transactionHash": "0x904ac8ed6c0618be2176821eac9f6f213105643d88bfabb5710307146aca3b6f",
        "address": "0x0000000000000000000000000000000000001010",
        "topics": [
          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
          "0x0000000000000000000000000000000000000000000000000000000000001010",
          "0x00000000000000000000000001cc16b92b9e0ce88dd7e7a6a90566a6bbb63a1f",
          "0x000000000000000000000000be188d6641e8b680743a4815dfa0f6208038960f"
        ],
        "data": "0x00000000000000000000000000000000000000000000000000229b5fcbfa3c2c0000000000000000000000000000000000000000000000001b49b940bb93c0000000000000000000000000000000000000000000000023b25da24358145c114b0000000000000000000000000000000000000000000000001b271de0ef9983d40000000000000000000000000000000000000000000023b25dc4deb7e0564d77",
        "logIndex": 11,
        "blockHash": "0xe38827a8c0724a7706ad77409bc219e7f7bac84041763d7b03eb2be5766a726c"
      }
    ],
    "blockNumber": 27709709,
    "cumulativeGasUsed": "720944",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "c12c2c7f6397a84bf26ce443943126f4",
  "metadata": "{\"compiler\":{\"version\":\"0.8.10+commit.fc410830\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"StartLoaning\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"StopLoaning\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"AAVE_POOL\",\"outputs\":[{\"internalType\":\"contract IPool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ADAI\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DAI\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startloanDAI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stopLoanDAI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"startloanDAI()\":{\"notice\":\"Deposit DAI into AAVE\"},\"stopLoanDAI()\":{\"notice\":\"Withdraw DAI from AAVE\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/WooshCore.sol\":\"WooshCore\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\",\"keccak256\":\"0x9750c6b834f7b43000631af5cc30001c5f547b3ceb3635488f140f60e897ea6b\",\"license\":\"MIT\"},\"contracts/WooshCore.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.10;\\r\\n\\r\\nimport \\\"./interface/IWooshCore.sol\\\";\\r\\nimport \\\"./interface/IPool.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\n\\r\\ncontract WooshCore is IWooshCore {\\r\\n    // To deposit token assets (USDT, DAI, USDC, AAVE, etc)\\r\\n    IPool public AAVE_POOL = IPool(0x6C9fB0D5bD9429eb9Cd96B85B81d872281771E6B);\\r\\n\\r\\n    // Address for WETH\\r\\n    IERC20 public DAI = IERC20(0x9A753f0F7886C9fbF63cF59D0D4423C5eFaCE95B);\\r\\n    IERC20 public ADAI = IERC20(0xDD4f3Ee61466C4158D394d57f3D4C397E91fBc51);\\r\\n\\r\\n    constructor() {}\\r\\n\\r\\n    /**\\r\\n     * @notice Deposit DAI into AAVE\\r\\n     */\\r\\n    function startloanDAI() external {\\r\\n        // Get balance of aDAI of user\\r\\n        uint256 _amount = DAI.balanceOf(msg.sender);\\r\\n\\r\\n        // DAI Supply pool on mumbai is full, so this call will always revert\\r\\n        AAVE_POOL.supply(address(DAI), _amount, msg.sender, 0);\\r\\n\\r\\n        // Emit Event\\r\\n        emit StartLoaning(msg.sender, address(DAI), _amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Withdraw DAI from AAVE\\r\\n     */\\r\\n    function stopLoanDAI() external {\\r\\n        // Get balance of aDAI of user\\r\\n        uint256 _amount = ADAI.balanceOf(msg.sender);\\r\\n\\r\\n        // Call Withdraw Function of GAAVEPool\\r\\n        AAVE_POOL.withdraw(address(DAI), _amount, msg.sender);\\r\\n\\r\\n        // emit event\\r\\n        emit StopLoaning(msg.sender, address(DAI), _amount);\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0xb32a636af2b148d4e7ccfb6b044885593790a2717dd9f66912cef14e3893d152\",\"license\":\"MIT\"},\"contracts/interface/DataTypes.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\r\\npragma solidity 0.8.10;\\r\\n\\r\\nlibrary DataTypes {\\r\\n    struct ReserveData {\\r\\n        //stores the reserve configuration\\r\\n        ReserveConfigurationMap configuration;\\r\\n        //the liquidity index. Expressed in ray\\r\\n        uint128 liquidityIndex;\\r\\n        //the current supply rate. Expressed in ray\\r\\n        uint128 currentLiquidityRate;\\r\\n        //variable borrow index. Expressed in ray\\r\\n        uint128 variableBorrowIndex;\\r\\n        //the current variable borrow rate. Expressed in ray\\r\\n        uint128 currentVariableBorrowRate;\\r\\n        //the current stable borrow rate. Expressed in ray\\r\\n        uint128 currentStableBorrowRate;\\r\\n        //timestamp of last update\\r\\n        uint40 lastUpdateTimestamp;\\r\\n        //the id of the reserve. Represents the position in the list of the active reserves\\r\\n        uint16 id;\\r\\n        //aToken address\\r\\n        address aTokenAddress;\\r\\n        //stableDebtToken address\\r\\n        address stableDebtTokenAddress;\\r\\n        //variableDebtToken address\\r\\n        address variableDebtTokenAddress;\\r\\n        //address of the interest rate strategy\\r\\n        address interestRateStrategyAddress;\\r\\n        //the current treasury balance, scaled\\r\\n        uint128 accruedToTreasury;\\r\\n        //the outstanding unbacked aTokens minted through the bridging feature\\r\\n        uint128 unbacked;\\r\\n        //the outstanding debt borrowed against this asset in isolation mode\\r\\n        uint128 isolationModeTotalDebt;\\r\\n    }\\r\\n\\r\\n    struct ReserveConfigurationMap {\\r\\n        //bit 0-15: LTV\\r\\n        //bit 16-31: Liq. threshold\\r\\n        //bit 32-47: Liq. bonus\\r\\n        //bit 48-55: Decimals\\r\\n        //bit 56: reserve is active\\r\\n        //bit 57: reserve is frozen\\r\\n        //bit 58: borrowing is enabled\\r\\n        //bit 59: stable rate borrowing enabled\\r\\n        //bit 60: asset is paused\\r\\n        //bit 61: borrowing in isolation mode is enabled\\r\\n        //bit 62-63: reserved\\r\\n        //bit 64-79: reserve factor\\r\\n        //bit 80-115 borrow cap in whole tokens, borrowCap == 0 => no cap\\r\\n        //bit 116-151 supply cap in whole tokens, supplyCap == 0 => no cap\\r\\n        //bit 152-167 liquidation protocol fee\\r\\n        //bit 168-175 eMode category\\r\\n        //bit 176-211 unbacked mint cap in whole tokens, unbackedMintCap == 0 => minting disabled\\r\\n        //bit 212-251 debt ceiling for isolation mode with (ReserveConfiguration::DEBT_CEILING_DECIMALS) decimals\\r\\n        //bit 252-255 unused\\r\\n\\r\\n        uint256 data;\\r\\n    }\\r\\n\\r\\n    struct UserConfigurationMap {\\r\\n        /**\\r\\n         * @dev Bitmap of the users collaterals and borrows. It is divided in pairs of bits, one pair per asset.\\r\\n         * The first bit indicates if an asset is used as collateral by the user, the second whether an\\r\\n         * asset is borrowed by the user.\\r\\n         */\\r\\n        uint256 data;\\r\\n    }\\r\\n\\r\\n    struct EModeCategory {\\r\\n        // each eMode category has a custom ltv and liquidation threshold\\r\\n        uint16 ltv;\\r\\n        uint16 liquidationThreshold;\\r\\n        uint16 liquidationBonus;\\r\\n        // each eMode category may or may not have a custom oracle to override the individual assets price oracles\\r\\n        address priceSource;\\r\\n        string label;\\r\\n    }\\r\\n\\r\\n    enum InterestRateMode {\\r\\n        NONE,\\r\\n        STABLE,\\r\\n        VARIABLE\\r\\n    }\\r\\n\\r\\n    struct ReserveCache {\\r\\n        uint256 currScaledVariableDebt;\\r\\n        uint256 nextScaledVariableDebt;\\r\\n        uint256 currPrincipalStableDebt;\\r\\n        uint256 currAvgStableBorrowRate;\\r\\n        uint256 currTotalStableDebt;\\r\\n        uint256 nextAvgStableBorrowRate;\\r\\n        uint256 nextTotalStableDebt;\\r\\n        uint256 currLiquidityIndex;\\r\\n        uint256 nextLiquidityIndex;\\r\\n        uint256 currVariableBorrowIndex;\\r\\n        uint256 nextVariableBorrowIndex;\\r\\n        uint256 currLiquidityRate;\\r\\n        uint256 currVariableBorrowRate;\\r\\n        uint256 reserveFactor;\\r\\n        ReserveConfigurationMap reserveConfiguration;\\r\\n        address aTokenAddress;\\r\\n        address stableDebtTokenAddress;\\r\\n        address variableDebtTokenAddress;\\r\\n        uint40 reserveLastUpdateTimestamp;\\r\\n        uint40 stableDebtLastUpdateTimestamp;\\r\\n    }\\r\\n\\r\\n    struct ExecuteLiquidationCallParams {\\r\\n        uint256 reservesCount;\\r\\n        uint256 debtToCover;\\r\\n        address collateralAsset;\\r\\n        address debtAsset;\\r\\n        address user;\\r\\n        bool receiveAToken;\\r\\n        address priceOracle;\\r\\n        uint8 userEModeCategory;\\r\\n        address priceOracleSentinel;\\r\\n    }\\r\\n\\r\\n    struct ExecuteSupplyParams {\\r\\n        address asset;\\r\\n        uint256 amount;\\r\\n        address onBehalfOf;\\r\\n        uint16 referralCode;\\r\\n    }\\r\\n\\r\\n    struct ExecuteBorrowParams {\\r\\n        address asset;\\r\\n        address user;\\r\\n        address onBehalfOf;\\r\\n        uint256 amount;\\r\\n        InterestRateMode interestRateMode;\\r\\n        uint16 referralCode;\\r\\n        bool releaseUnderlying;\\r\\n        uint256 maxStableRateBorrowSizePercent;\\r\\n        uint256 reservesCount;\\r\\n        address oracle;\\r\\n        uint8 userEModeCategory;\\r\\n        address priceOracleSentinel;\\r\\n    }\\r\\n\\r\\n    struct ExecuteRepayParams {\\r\\n        address asset;\\r\\n        uint256 amount;\\r\\n        InterestRateMode interestRateMode;\\r\\n        address onBehalfOf;\\r\\n        bool useATokens;\\r\\n    }\\r\\n\\r\\n    struct ExecuteWithdrawParams {\\r\\n        address asset;\\r\\n        uint256 amount;\\r\\n        address to;\\r\\n        uint256 reservesCount;\\r\\n        address oracle;\\r\\n        uint8 userEModeCategory;\\r\\n    }\\r\\n\\r\\n    struct ExecuteSetUserEModeParams {\\r\\n        uint256 reservesCount;\\r\\n        address oracle;\\r\\n        uint8 categoryId;\\r\\n    }\\r\\n\\r\\n    struct FinalizeTransferParams {\\r\\n        address asset;\\r\\n        address from;\\r\\n        address to;\\r\\n        uint256 amount;\\r\\n        uint256 balanceFromBefore;\\r\\n        uint256 balanceToBefore;\\r\\n        uint256 reservesCount;\\r\\n        address oracle;\\r\\n        uint8 fromEModeCategory;\\r\\n    }\\r\\n\\r\\n    struct FlashloanParams {\\r\\n        address receiverAddress;\\r\\n        address[] assets;\\r\\n        uint256[] amounts;\\r\\n        uint256[] interestRateModes;\\r\\n        address onBehalfOf;\\r\\n        bytes params;\\r\\n        uint16 referralCode;\\r\\n        uint256 flashLoanPremiumToProtocol;\\r\\n        uint256 flashLoanPremiumTotal;\\r\\n        uint256 maxStableRateBorrowSizePercent;\\r\\n        uint256 reservesCount;\\r\\n        address addressesProvider;\\r\\n        uint8 userEModeCategory;\\r\\n        bool isAuthorizedFlashBorrower;\\r\\n    }\\r\\n\\r\\n    struct FlashloanSimpleParams {\\r\\n        address receiverAddress;\\r\\n        address asset;\\r\\n        uint256 amount;\\r\\n        bytes params;\\r\\n        uint16 referralCode;\\r\\n        uint256 flashLoanPremiumToProtocol;\\r\\n        uint256 flashLoanPremiumTotal;\\r\\n    }\\r\\n\\r\\n    struct FlashLoanRepaymentParams {\\r\\n        uint256 amount;\\r\\n        uint256 totalPremium;\\r\\n        uint256 flashLoanPremiumToProtocol;\\r\\n        address asset;\\r\\n        address receiverAddress;\\r\\n        uint16 referralCode;\\r\\n    }\\r\\n\\r\\n    struct CalculateUserAccountDataParams {\\r\\n        UserConfigurationMap userConfig;\\r\\n        uint256 reservesCount;\\r\\n        address user;\\r\\n        address oracle;\\r\\n        uint8 userEModeCategory;\\r\\n    }\\r\\n\\r\\n    struct ValidateBorrowParams {\\r\\n        ReserveCache reserveCache;\\r\\n        UserConfigurationMap userConfig;\\r\\n        address asset;\\r\\n        address userAddress;\\r\\n        uint256 amount;\\r\\n        InterestRateMode interestRateMode;\\r\\n        uint256 maxStableLoanPercent;\\r\\n        uint256 reservesCount;\\r\\n        address oracle;\\r\\n        uint8 userEModeCategory;\\r\\n        address priceOracleSentinel;\\r\\n        bool isolationModeActive;\\r\\n        address isolationModeCollateralAddress;\\r\\n        uint256 isolationModeDebtCeiling;\\r\\n    }\\r\\n\\r\\n    struct ValidateLiquidationCallParams {\\r\\n        ReserveCache debtReserveCache;\\r\\n        uint256 totalDebt;\\r\\n        uint256 healthFactor;\\r\\n        address priceOracleSentinel;\\r\\n    }\\r\\n\\r\\n    struct CalculateInterestRatesParams {\\r\\n        uint256 unbacked;\\r\\n        uint256 liquidityAdded;\\r\\n        uint256 liquidityTaken;\\r\\n        uint256 totalStableDebt;\\r\\n        uint256 totalVariableDebt;\\r\\n        uint256 averageStableBorrowRate;\\r\\n        uint256 reserveFactor;\\r\\n        address reserve;\\r\\n        address aToken;\\r\\n    }\\r\\n\\r\\n    struct InitReserveParams {\\r\\n        address asset;\\r\\n        address aTokenAddress;\\r\\n        address stableDebtAddress;\\r\\n        address variableDebtAddress;\\r\\n        address interestRateStrategyAddress;\\r\\n        uint16 reservesCount;\\r\\n        uint16 maxNumberReserves;\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x284c378e44b2c75b5bb9aec663db538417def88a591a7fa91cb09a3d577d78e1\",\"license\":\"BUSL-1.1\"},\"contracts/interface/IPool.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\r\\npragma solidity 0.8.10;\\r\\n\\r\\nimport {IPoolAddressesProvider} from \\\"./IPoolAddressesProvider.sol\\\";\\r\\nimport {DataTypes} from \\\"./DataTypes.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title IPool\\r\\n * @author Aave\\r\\n * @notice Defines the basic interface for an Aave Pool.\\r\\n **/\\r\\ninterface IPool {\\r\\n    /**\\r\\n     * @dev Emitted on mintUnbacked()\\r\\n     * @param reserve The address of the underlying asset of the reserve\\r\\n     * @param user The address initiating the supply\\r\\n     * @param onBehalfOf The beneficiary of the supplied assets, receiving the aTokens\\r\\n     * @param amount The amount of supplied assets\\r\\n     * @param referralCode The referral code used\\r\\n     **/\\r\\n    event MintUnbacked(\\r\\n        address indexed reserve,\\r\\n        address user,\\r\\n        address indexed onBehalfOf,\\r\\n        uint256 amount,\\r\\n        uint16 indexed referralCode\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted on backUnbacked()\\r\\n     * @param reserve The address of the underlying asset of the reserve\\r\\n     * @param backer The address paying for the backing\\r\\n     * @param amount The amount added as backing\\r\\n     * @param fee The amount paid in fees\\r\\n     **/\\r\\n    event BackUnbacked(\\r\\n        address indexed reserve,\\r\\n        address indexed backer,\\r\\n        uint256 amount,\\r\\n        uint256 fee\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted on supply()\\r\\n     * @param reserve The address of the underlying asset of the reserve\\r\\n     * @param user The address initiating the supply\\r\\n     * @param onBehalfOf The beneficiary of the supply, receiving the aTokens\\r\\n     * @param amount The amount supplied\\r\\n     * @param referralCode The referral code used\\r\\n     **/\\r\\n    event Supply(\\r\\n        address indexed reserve,\\r\\n        address user,\\r\\n        address indexed onBehalfOf,\\r\\n        uint256 amount,\\r\\n        uint16 indexed referralCode\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted on withdraw()\\r\\n     * @param reserve The address of the underlying asset being withdrawn\\r\\n     * @param user The address initiating the withdrawal, owner of aTokens\\r\\n     * @param to The address that will receive the underlying\\r\\n     * @param amount The amount to be withdrawn\\r\\n     **/\\r\\n    event Withdraw(\\r\\n        address indexed reserve,\\r\\n        address indexed user,\\r\\n        address indexed to,\\r\\n        uint256 amount\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\\r\\n     * @param reserve The address of the underlying asset being borrowed\\r\\n     * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just\\r\\n     * initiator of the transaction on flashLoan()\\r\\n     * @param onBehalfOf The address that will be getting the debt\\r\\n     * @param amount The amount borrowed out\\r\\n     * @param interestRateMode The rate mode: 1 for Stable, 2 for Variable\\r\\n     * @param borrowRate The numeric rate at which the user has borrowed, expressed in ray\\r\\n     * @param referralCode The referral code used\\r\\n     **/\\r\\n    event Borrow(\\r\\n        address indexed reserve,\\r\\n        address user,\\r\\n        address indexed onBehalfOf,\\r\\n        uint256 amount,\\r\\n        DataTypes.InterestRateMode interestRateMode,\\r\\n        uint256 borrowRate,\\r\\n        uint16 indexed referralCode\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted on repay()\\r\\n     * @param reserve The address of the underlying asset of the reserve\\r\\n     * @param user The beneficiary of the repayment, getting his debt reduced\\r\\n     * @param repayer The address of the user initiating the repay(), providing the funds\\r\\n     * @param amount The amount repaid\\r\\n     * @param useATokens True if the repayment is done using aTokens, `false` if done with underlying asset directly\\r\\n     **/\\r\\n    event Repay(\\r\\n        address indexed reserve,\\r\\n        address indexed user,\\r\\n        address indexed repayer,\\r\\n        uint256 amount,\\r\\n        bool useATokens\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted on swapBorrowRateMode()\\r\\n     * @param reserve The address of the underlying asset of the reserve\\r\\n     * @param user The address of the user swapping his rate mode\\r\\n     * @param interestRateMode The current interest rate mode of the position being swapped: 1 for Stable, 2 for Variable\\r\\n     **/\\r\\n    event SwapBorrowRateMode(\\r\\n        address indexed reserve,\\r\\n        address indexed user,\\r\\n        DataTypes.InterestRateMode interestRateMode\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted on borrow(), repay() and liquidationCall() when using isolated assets\\r\\n     * @param asset The address of the underlying asset of the reserve\\r\\n     * @param totalDebt The total isolation mode debt for the reserve\\r\\n     */\\r\\n    event IsolationModeTotalDebtUpdated(\\r\\n        address indexed asset,\\r\\n        uint256 totalDebt\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the user selects a certain asset category for eMode\\r\\n     * @param user The address of the user\\r\\n     * @param categoryId The category id\\r\\n     **/\\r\\n    event UserEModeSet(address indexed user, uint8 categoryId);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted on setUserUseReserveAsCollateral()\\r\\n     * @param reserve The address of the underlying asset of the reserve\\r\\n     * @param user The address of the user enabling the usage as collateral\\r\\n     **/\\r\\n    event ReserveUsedAsCollateralEnabled(\\r\\n        address indexed reserve,\\r\\n        address indexed user\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted on setUserUseReserveAsCollateral()\\r\\n     * @param reserve The address of the underlying asset of the reserve\\r\\n     * @param user The address of the user enabling the usage as collateral\\r\\n     **/\\r\\n    event ReserveUsedAsCollateralDisabled(\\r\\n        address indexed reserve,\\r\\n        address indexed user\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted on rebalanceStableBorrowRate()\\r\\n     * @param reserve The address of the underlying asset of the reserve\\r\\n     * @param user The address of the user for which the rebalance has been executed\\r\\n     **/\\r\\n    event RebalanceStableBorrowRate(\\r\\n        address indexed reserve,\\r\\n        address indexed user\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted on flashLoan()\\r\\n     * @param target The address of the flash loan receiver contract\\r\\n     * @param initiator The address initiating the flash loan\\r\\n     * @param asset The address of the asset being flash borrowed\\r\\n     * @param amount The amount flash borrowed\\r\\n     * @param interestRateMode The flashloan mode: 0 for regular flashloan, 1 for Stable debt, 2 for Variable debt\\r\\n     * @param premium The fee flash borrowed\\r\\n     * @param referralCode The referral code used\\r\\n     **/\\r\\n    event FlashLoan(\\r\\n        address indexed target,\\r\\n        address initiator,\\r\\n        address indexed asset,\\r\\n        uint256 amount,\\r\\n        DataTypes.InterestRateMode interestRateMode,\\r\\n        uint256 premium,\\r\\n        uint16 indexed referralCode\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when a borrower is liquidated.\\r\\n     * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\\r\\n     * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\\r\\n     * @param user The address of the borrower getting liquidated\\r\\n     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\\r\\n     * @param liquidatedCollateralAmount The amount of collateral received by the liquidator\\r\\n     * @param liquidator The address of the liquidator\\r\\n     * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\\r\\n     * to receive the underlying collateral asset directly\\r\\n     **/\\r\\n    event LiquidationCall(\\r\\n        address indexed collateralAsset,\\r\\n        address indexed debtAsset,\\r\\n        address indexed user,\\r\\n        uint256 debtToCover,\\r\\n        uint256 liquidatedCollateralAmount,\\r\\n        address liquidator,\\r\\n        bool receiveAToken\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the state of a reserve is updated.\\r\\n     * @param reserve The address of the underlying asset of the reserve\\r\\n     * @param liquidityRate The next liquidity rate\\r\\n     * @param stableBorrowRate The next stable borrow rate\\r\\n     * @param variableBorrowRate The next variable borrow rate\\r\\n     * @param liquidityIndex The next liquidity index\\r\\n     * @param variableBorrowIndex The next variable borrow index\\r\\n     **/\\r\\n    event ReserveDataUpdated(\\r\\n        address indexed reserve,\\r\\n        uint256 liquidityRate,\\r\\n        uint256 stableBorrowRate,\\r\\n        uint256 variableBorrowRate,\\r\\n        uint256 liquidityIndex,\\r\\n        uint256 variableBorrowIndex\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the protocol treasury receives minted aTokens from the accrued interest.\\r\\n     * @param reserve The address of the reserve\\r\\n     * @param amountMinted The amount minted to the treasury\\r\\n     **/\\r\\n    event MintedToTreasury(address indexed reserve, uint256 amountMinted);\\r\\n\\r\\n    /**\\r\\n     * @dev Mints an `amount` of aTokens to the `onBehalfOf`\\r\\n     * @param asset The address of the underlying asset to mint\\r\\n     * @param amount The amount to mint\\r\\n     * @param onBehalfOf The address that will receive the aTokens\\r\\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\\r\\n     *   0 if the action is executed directly by the user, without any middle-man\\r\\n     **/\\r\\n    function mintUnbacked(\\r\\n        address asset,\\r\\n        uint256 amount,\\r\\n        address onBehalfOf,\\r\\n        uint16 referralCode\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Back the current unbacked underlying with `amount` and pay `fee`.\\r\\n     * @param asset The address of the underlying asset to back\\r\\n     * @param amount The amount to back\\r\\n     * @param fee The amount paid in fees\\r\\n     **/\\r\\n    function backUnbacked(\\r\\n        address asset,\\r\\n        uint256 amount,\\r\\n        uint256 fee\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\\r\\n     * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\\r\\n     * @param asset The address of the underlying asset to supply\\r\\n     * @param amount The amount to be supplied\\r\\n     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\\r\\n     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\\r\\n     *   is a different wallet\\r\\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\\r\\n     *   0 if the action is executed directly by the user, without any middle-man\\r\\n     **/\\r\\n    function supply(\\r\\n        address asset,\\r\\n        uint256 amount,\\r\\n        address onBehalfOf,\\r\\n        uint16 referralCode\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Supply with transfer approval of asset to be supplied done via permit function\\r\\n     * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713\\r\\n     * @param asset The address of the underlying asset to supply\\r\\n     * @param amount The amount to be supplied\\r\\n     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\\r\\n     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\\r\\n     *   is a different wallet\\r\\n     * @param deadline The deadline timestamp that the permit is valid\\r\\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\\r\\n     *   0 if the action is executed directly by the user, without any middle-man\\r\\n     * @param permitV The V parameter of ERC712 permit sig\\r\\n     * @param permitR The R parameter of ERC712 permit sig\\r\\n     * @param permitS The S parameter of ERC712 permit sig\\r\\n     **/\\r\\n    function supplyWithPermit(\\r\\n        address asset,\\r\\n        uint256 amount,\\r\\n        address onBehalfOf,\\r\\n        uint16 referralCode,\\r\\n        uint256 deadline,\\r\\n        uint8 permitV,\\r\\n        bytes32 permitR,\\r\\n        bytes32 permitS\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\\r\\n     * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\\r\\n     * @param asset The address of the underlying asset to withdraw\\r\\n     * @param amount The underlying amount to be withdrawn\\r\\n     *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\\r\\n     * @param to The address that will receive the underlying, same as msg.sender if the user\\r\\n     *   wants to receive it on his own wallet, or a different address if the beneficiary is a\\r\\n     *   different wallet\\r\\n     * @return The final amount withdrawn\\r\\n     **/\\r\\n    function withdraw(\\r\\n        address asset,\\r\\n        uint256 amount,\\r\\n        address to\\r\\n    ) external returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @notice Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\\r\\n     * already supplied enough collateral, or he was given enough allowance by a credit delegator on the\\r\\n     * corresponding debt token (StableDebtToken or VariableDebtToken)\\r\\n     * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\\r\\n     *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\\r\\n     * @param asset The address of the underlying asset to borrow\\r\\n     * @param amount The amount to be borrowed\\r\\n     * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\\r\\n     * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\\r\\n     *   0 if the action is executed directly by the user, without any middle-man\\r\\n     * @param onBehalfOf The address of the user who will receive the debt. Should be the address of the borrower itself\\r\\n     * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\\r\\n     * if he has been given credit delegation allowance\\r\\n     **/\\r\\n    function borrow(\\r\\n        address asset,\\r\\n        uint256 amount,\\r\\n        uint256 interestRateMode,\\r\\n        uint16 referralCode,\\r\\n        address onBehalfOf\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\\r\\n     * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\\r\\n     * @param asset The address of the borrowed underlying asset previously borrowed\\r\\n     * @param amount The amount to repay\\r\\n     * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\\r\\n     * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\\r\\n     * @param onBehalfOf The address of the user who will get his debt reduced/removed. Should be the address of the\\r\\n     * user calling the function if he wants to reduce/remove his own debt, or the address of any other\\r\\n     * other borrower whose debt should be removed\\r\\n     * @return The final amount repaid\\r\\n     **/\\r\\n    function repay(\\r\\n        address asset,\\r\\n        uint256 amount,\\r\\n        uint256 interestRateMode,\\r\\n        address onBehalfOf\\r\\n    ) external returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @notice Repay with transfer approval of asset to be repaid done via permit function\\r\\n     * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713\\r\\n     * @param asset The address of the borrowed underlying asset previously borrowed\\r\\n     * @param amount The amount to repay\\r\\n     * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\\r\\n     * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\\r\\n     * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\\r\\n     * user calling the function if he wants to reduce/remove his own debt, or the address of any other\\r\\n     * other borrower whose debt should be removed\\r\\n     * @param deadline The deadline timestamp that the permit is valid\\r\\n     * @param permitV The V parameter of ERC712 permit sig\\r\\n     * @param permitR The R parameter of ERC712 permit sig\\r\\n     * @param permitS The S parameter of ERC712 permit sig\\r\\n     * @return The final amount repaid\\r\\n     **/\\r\\n    function repayWithPermit(\\r\\n        address asset,\\r\\n        uint256 amount,\\r\\n        uint256 interestRateMode,\\r\\n        address onBehalfOf,\\r\\n        uint256 deadline,\\r\\n        uint8 permitV,\\r\\n        bytes32 permitR,\\r\\n        bytes32 permitS\\r\\n    ) external returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @notice Repays a borrowed `amount` on a specific reserve using the reserve aTokens, burning the\\r\\n     * equivalent debt tokens\\r\\n     * - E.g. User repays 100 USDC using 100 aUSDC, burning 100 variable/stable debt tokens\\r\\n     * @dev  Passing uint256.max as amount will clean up any residual aToken dust balance, if the user aToken\\r\\n     * balance is not enough to cover the whole debt\\r\\n     * @param asset The address of the borrowed underlying asset previously borrowed\\r\\n     * @param amount The amount to repay\\r\\n     * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\\r\\n     * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\\r\\n     * @return The final amount repaid\\r\\n     **/\\r\\n    function repayWithATokens(\\r\\n        address asset,\\r\\n        uint256 amount,\\r\\n        uint256 interestRateMode\\r\\n    ) external returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @notice Allows a borrower to swap his debt between stable and variable mode, or vice versa\\r\\n     * @param asset The address of the underlying asset borrowed\\r\\n     * @param interestRateMode The current interest rate mode of the position being swapped: 1 for Stable, 2 for Variable\\r\\n     **/\\r\\n    function swapBorrowRateMode(address asset, uint256 interestRateMode)\\r\\n        external;\\r\\n\\r\\n    /**\\r\\n     * @notice Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\\r\\n     * - Users can be rebalanced if the following conditions are satisfied:\\r\\n     *     1. Usage ratio is above 95%\\r\\n     *     2. the current supply APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too\\r\\n     *        much has been borrowed at a stable rate and suppliers are not earning enough\\r\\n     * @param asset The address of the underlying asset borrowed\\r\\n     * @param user The address of the user to be rebalanced\\r\\n     **/\\r\\n    function rebalanceStableBorrowRate(address asset, address user) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Allows suppliers to enable/disable a specific supplied asset as collateral\\r\\n     * @param asset The address of the underlying asset supplied\\r\\n     * @param useAsCollateral True if the user wants to use the supply as collateral, false otherwise\\r\\n     **/\\r\\n    function setUserUseReserveAsCollateral(address asset, bool useAsCollateral)\\r\\n        external;\\r\\n\\r\\n    /**\\r\\n     * @notice Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\\r\\n     * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\\r\\n     *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\\r\\n     * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\\r\\n     * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\\r\\n     * @param user The address of the borrower getting liquidated\\r\\n     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\\r\\n     * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\\r\\n     * to receive the underlying collateral asset directly\\r\\n     **/\\r\\n    function liquidationCall(\\r\\n        address collateralAsset,\\r\\n        address debtAsset,\\r\\n        address user,\\r\\n        uint256 debtToCover,\\r\\n        bool receiveAToken\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\\r\\n     * as long as the amount taken plus a fee is returned.\\r\\n     * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\\r\\n     * into consideration. For further details please visit https://developers.aave.com\\r\\n     * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanReceiver interface\\r\\n     * @param assets The addresses of the assets being flash-borrowed\\r\\n     * @param amounts The amounts of the assets being flash-borrowed\\r\\n     * @param interestRateModes Types of the debt to open if the flash loan is not returned:\\r\\n     *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\\r\\n     *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\\r\\n     *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\\r\\n     * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\\r\\n     * @param params Variadic packed params to pass to the receiver as extra information\\r\\n     * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\\r\\n     *   0 if the action is executed directly by the user, without any middle-man\\r\\n     **/\\r\\n    function flashLoan(\\r\\n        address receiverAddress,\\r\\n        address[] calldata assets,\\r\\n        uint256[] calldata amounts,\\r\\n        uint256[] calldata interestRateModes,\\r\\n        address onBehalfOf,\\r\\n        bytes calldata params,\\r\\n        uint16 referralCode\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\\r\\n     * as long as the amount taken plus a fee is returned.\\r\\n     * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\\r\\n     * into consideration. For further details please visit https://developers.aave.com\\r\\n     * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanSimpleReceiver interface\\r\\n     * @param asset The address of the asset being flash-borrowed\\r\\n     * @param amount The amount of the asset being flash-borrowed\\r\\n     * @param params Variadic packed params to pass to the receiver as extra information\\r\\n     * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\\r\\n     *   0 if the action is executed directly by the user, without any middle-man\\r\\n     **/\\r\\n    function flashLoanSimple(\\r\\n        address receiverAddress,\\r\\n        address asset,\\r\\n        uint256 amount,\\r\\n        bytes calldata params,\\r\\n        uint16 referralCode\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the user account data across all the reserves\\r\\n     * @param user The address of the user\\r\\n     * @return totalCollateralBase The total collateral of the user in the base currency used by the price feed\\r\\n     * @return totalDebtBase The total debt of the user in the base currency used by the price feed\\r\\n     * @return availableBorrowsBase The borrowing power left of the user in the base currency used by the price feed\\r\\n     * @return currentLiquidationThreshold The liquidation threshold of the user\\r\\n     * @return ltv The loan to value of The user\\r\\n     * @return healthFactor The current health factor of the user\\r\\n     **/\\r\\n    function getUserAccountData(address user)\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            uint256 totalCollateralBase,\\r\\n            uint256 totalDebtBase,\\r\\n            uint256 availableBorrowsBase,\\r\\n            uint256 currentLiquidationThreshold,\\r\\n            uint256 ltv,\\r\\n            uint256 healthFactor\\r\\n        );\\r\\n\\r\\n    /**\\r\\n     * @notice Initializes a reserve, activating it, assigning an aToken and debt tokens and an\\r\\n     * interest rate strategy\\r\\n     * @dev Only callable by the PoolConfigurator contract\\r\\n     * @param asset The address of the underlying asset of the reserve\\r\\n     * @param aTokenAddress The address of the aToken that will be assigned to the reserve\\r\\n     * @param stableDebtAddress The address of the StableDebtToken that will be assigned to the reserve\\r\\n     * @param variableDebtAddress The address of the VariableDebtToken that will be assigned to the reserve\\r\\n     * @param interestRateStrategyAddress The address of the interest rate strategy contract\\r\\n     **/\\r\\n    function initReserve(\\r\\n        address asset,\\r\\n        address aTokenAddress,\\r\\n        address stableDebtAddress,\\r\\n        address variableDebtAddress,\\r\\n        address interestRateStrategyAddress\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Drop a reserve\\r\\n     * @dev Only callable by the PoolConfigurator contract\\r\\n     * @param asset The address of the underlying asset of the reserve\\r\\n     **/\\r\\n    function dropReserve(address asset) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Updates the address of the interest rate strategy contract\\r\\n     * @dev Only callable by the PoolConfigurator contract\\r\\n     * @param asset The address of the underlying asset of the reserve\\r\\n     * @param rateStrategyAddress The address of the interest rate strategy contract\\r\\n     **/\\r\\n    function setReserveInterestRateStrategyAddress(\\r\\n        address asset,\\r\\n        address rateStrategyAddress\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Sets the configuration bitmap of the reserve as a whole\\r\\n     * @dev Only callable by the PoolConfigurator contract\\r\\n     * @param asset The address of the underlying asset of the reserve\\r\\n     * @param configuration The new configuration bitmap\\r\\n     **/\\r\\n    function setConfiguration(\\r\\n        address asset,\\r\\n        DataTypes.ReserveConfigurationMap calldata configuration\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the configuration of the reserve\\r\\n     * @param asset The address of the underlying asset of the reserve\\r\\n     * @return The configuration of the reserve\\r\\n     **/\\r\\n    function getConfiguration(address asset)\\r\\n        external\\r\\n        view\\r\\n        returns (DataTypes.ReserveConfigurationMap memory);\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the configuration of the user across all the reserves\\r\\n     * @param user The user address\\r\\n     * @return The configuration of the user\\r\\n     **/\\r\\n    function getUserConfiguration(address user)\\r\\n        external\\r\\n        view\\r\\n        returns (DataTypes.UserConfigurationMap memory);\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the normalized income normalized income of the reserve\\r\\n     * @param asset The address of the underlying asset of the reserve\\r\\n     * @return The reserve's normalized income\\r\\n     */\\r\\n    function getReserveNormalizedIncome(address asset)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the normalized variable debt per unit of asset\\r\\n     * @param asset The address of the underlying asset of the reserve\\r\\n     * @return The reserve normalized variable debt\\r\\n     */\\r\\n    function getReserveNormalizedVariableDebt(address asset)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the state and configuration of the reserve\\r\\n     * @param asset The address of the underlying asset of the reserve\\r\\n     * @return The state and configuration data of the reserve\\r\\n     **/\\r\\n    function getReserveData(address asset)\\r\\n        external\\r\\n        view\\r\\n        returns (DataTypes.ReserveData memory);\\r\\n\\r\\n    /**\\r\\n     * @notice Validates and finalizes an aToken transfer\\r\\n     * @dev Only callable by the overlying aToken of the `asset`\\r\\n     * @param asset The address of the underlying asset of the aToken\\r\\n     * @param from The user from which the aTokens are transferred\\r\\n     * @param to The user receiving the aTokens\\r\\n     * @param amount The amount being transferred/withdrawn\\r\\n     * @param balanceFromBefore The aToken balance of the `from` user before the transfer\\r\\n     * @param balanceToBefore The aToken balance of the `to` user before the transfer\\r\\n     */\\r\\n    function finalizeTransfer(\\r\\n        address asset,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount,\\r\\n        uint256 balanceFromBefore,\\r\\n        uint256 balanceToBefore\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the list of the underlying assets of all the initialized reserves\\r\\n     * @dev It does not include dropped reserves\\r\\n     * @return The addresses of the underlying assets of the initialized reserves\\r\\n     **/\\r\\n    function getReservesList() external view returns (address[] memory);\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the address of the underlying asset of a reserve by the reserve id as stored in the DataTypes.ReserveData struct\\r\\n     * @param id The id of the reserve as stored in the DataTypes.ReserveData struct\\r\\n     * @return The address of the reserve associated with id\\r\\n     **/\\r\\n    function getReserveAddressById(uint16 id) external view returns (address);\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the PoolAddressesProvider connected to this contract\\r\\n     * @return The address of the PoolAddressesProvider\\r\\n     **/\\r\\n    function ADDRESSES_PROVIDER()\\r\\n        external\\r\\n        view\\r\\n        returns (IPoolAddressesProvider);\\r\\n\\r\\n    /**\\r\\n     * @notice Updates the protocol fee on the bridging\\r\\n     * @param bridgeProtocolFee The part of the premium sent to the protocol treasury\\r\\n     */\\r\\n    function updateBridgeProtocolFee(uint256 bridgeProtocolFee) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Updates flash loan premiums. Flash loan premium consists of two parts:\\r\\n     * - A part is sent to aToken holders as extra, one time accumulated interest\\r\\n     * - A part is collected by the protocol treasury\\r\\n     * @dev The total premium is calculated on the total borrowed amount\\r\\n     * @dev The premium to protocol is calculated on the total premium, being a percentage of `flashLoanPremiumTotal`\\r\\n     * @dev Only callable by the PoolConfigurator contract\\r\\n     * @param flashLoanPremiumTotal The total premium, expressed in bps\\r\\n     * @param flashLoanPremiumToProtocol The part of the premium sent to the protocol treasury, expressed in bps\\r\\n     */\\r\\n    function updateFlashloanPremiums(\\r\\n        uint128 flashLoanPremiumTotal,\\r\\n        uint128 flashLoanPremiumToProtocol\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Configures a new category for the eMode.\\r\\n     * @dev In eMode, the protocol allows very high borrowing power to borrow assets of the same category.\\r\\n     * The category 0 is reserved as it's the default for volatile assets\\r\\n     * @param id The id of the category\\r\\n     * @param config The configuration of the category\\r\\n     */\\r\\n    function configureEModeCategory(\\r\\n        uint8 id,\\r\\n        DataTypes.EModeCategory memory config\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the data of an eMode category\\r\\n     * @param id The id of the category\\r\\n     * @return The configuration data of the category\\r\\n     */\\r\\n    function getEModeCategoryData(uint8 id)\\r\\n        external\\r\\n        view\\r\\n        returns (DataTypes.EModeCategory memory);\\r\\n\\r\\n    /**\\r\\n     * @notice Allows a user to use the protocol in eMode\\r\\n     * @param categoryId The id of the category\\r\\n     */\\r\\n    function setUserEMode(uint8 categoryId) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the eMode the user is using\\r\\n     * @param user The address of the user\\r\\n     * @return The eMode id\\r\\n     */\\r\\n    function getUserEMode(address user) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @notice Resets the isolation mode total debt of the given asset to zero\\r\\n     * @dev It requires the given asset has zero debt ceiling\\r\\n     * @param asset The address of the underlying asset to reset the isolationModeTotalDebt\\r\\n     */\\r\\n    function resetIsolationModeTotalDebt(address asset) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the percentage of available liquidity that can be borrowed at once at stable rate\\r\\n     * @return The percentage of available liquidity to borrow, expressed in bps\\r\\n     */\\r\\n    function MAX_STABLE_RATE_BORROW_SIZE_PERCENT()\\r\\n        external\\r\\n        view\\r\\n        returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the total fee on flash loans\\r\\n     * @return The total fee on flashloans\\r\\n     */\\r\\n    function FLASHLOAN_PREMIUM_TOTAL() external view returns (uint128);\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the part of the bridge fees sent to protocol\\r\\n     * @return The bridge fee sent to the protocol treasury\\r\\n     */\\r\\n    function BRIDGE_PROTOCOL_FEE() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the part of the flashloan fees sent to protocol\\r\\n     * @return The flashloan fee sent to the protocol treasury\\r\\n     */\\r\\n    function FLASHLOAN_PREMIUM_TO_PROTOCOL() external view returns (uint128);\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the maximum number of reserves supported to be listed in this Pool\\r\\n     * @return The maximum number of reserves supported\\r\\n     */\\r\\n    function MAX_NUMBER_RESERVES() external view returns (uint16);\\r\\n\\r\\n    /**\\r\\n     * @notice Mints the assets accrued through the reserve factor to the treasury in the form of aTokens\\r\\n     * @param assets The list of reserves for which the minting needs to be executed\\r\\n     **/\\r\\n    function mintToTreasury(address[] calldata assets) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Rescue and transfer tokens locked in this contract\\r\\n     * @param token The address of the token\\r\\n     * @param to The address of the recipient\\r\\n     * @param amount The amount of token to transfer\\r\\n     */\\r\\n    function rescueTokens(\\r\\n        address token,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\\r\\n     * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\\r\\n     * @dev Deprecated: Use the `supply` function instead\\r\\n     * @param asset The address of the underlying asset to supply\\r\\n     * @param amount The amount to be supplied\\r\\n     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\\r\\n     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\\r\\n     *   is a different wallet\\r\\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\\r\\n     *   0 if the action is executed directly by the user, without any middle-man\\r\\n     **/\\r\\n    function deposit(\\r\\n        address asset,\\r\\n        uint256 amount,\\r\\n        address onBehalfOf,\\r\\n        uint16 referralCode\\r\\n    ) external;\\r\\n}\\r\\n\",\"keccak256\":\"0x796aacd49a10e3aae85dba9d9145b218a7afd5c070cd0a9bd932ccc64207f846\",\"license\":\"AGPL-3.0\"},\"contracts/interface/IPoolAddressesProvider.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\r\\npragma solidity 0.8.10;\\r\\n\\r\\n/**\\r\\n * @title IPoolAddressesProvider\\r\\n * @author Aave\\r\\n * @notice Defines the basic interface for a Pool Addresses Provider.\\r\\n **/\\r\\ninterface IPoolAddressesProvider {\\r\\n    /**\\r\\n     * @dev Emitted when the market identifier is updated.\\r\\n     * @param oldMarketId The old id of the market\\r\\n     * @param newMarketId The new id of the market\\r\\n     */\\r\\n    event MarketIdSet(string indexed oldMarketId, string indexed newMarketId);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the pool is updated.\\r\\n     * @param oldAddress The old address of the Pool\\r\\n     * @param newAddress The new address of the Pool\\r\\n     */\\r\\n    event PoolUpdated(address indexed oldAddress, address indexed newAddress);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the pool configurator is updated.\\r\\n     * @param oldAddress The old address of the PoolConfigurator\\r\\n     * @param newAddress The new address of the PoolConfigurator\\r\\n     */\\r\\n    event PoolConfiguratorUpdated(\\r\\n        address indexed oldAddress,\\r\\n        address indexed newAddress\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the price oracle is updated.\\r\\n     * @param oldAddress The old address of the PriceOracle\\r\\n     * @param newAddress The new address of the PriceOracle\\r\\n     */\\r\\n    event PriceOracleUpdated(\\r\\n        address indexed oldAddress,\\r\\n        address indexed newAddress\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the ACL manager is updated.\\r\\n     * @param oldAddress The old address of the ACLManager\\r\\n     * @param newAddress The new address of the ACLManager\\r\\n     */\\r\\n    event ACLManagerUpdated(\\r\\n        address indexed oldAddress,\\r\\n        address indexed newAddress\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the ACL admin is updated.\\r\\n     * @param oldAddress The old address of the ACLAdmin\\r\\n     * @param newAddress The new address of the ACLAdmin\\r\\n     */\\r\\n    event ACLAdminUpdated(\\r\\n        address indexed oldAddress,\\r\\n        address indexed newAddress\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the price oracle sentinel is updated.\\r\\n     * @param oldAddress The old address of the PriceOracleSentinel\\r\\n     * @param newAddress The new address of the PriceOracleSentinel\\r\\n     */\\r\\n    event PriceOracleSentinelUpdated(\\r\\n        address indexed oldAddress,\\r\\n        address indexed newAddress\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the pool data provider is updated.\\r\\n     * @param oldAddress The old address of the PoolDataProvider\\r\\n     * @param newAddress The new address of the PoolDataProvider\\r\\n     */\\r\\n    event PoolDataProviderUpdated(\\r\\n        address indexed oldAddress,\\r\\n        address indexed newAddress\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when a new proxy is created.\\r\\n     * @param id The identifier of the proxy\\r\\n     * @param proxyAddress The address of the created proxy contract\\r\\n     * @param implementationAddress The address of the implementation contract\\r\\n     */\\r\\n    event ProxyCreated(\\r\\n        bytes32 indexed id,\\r\\n        address indexed proxyAddress,\\r\\n        address indexed implementationAddress\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when a new non-proxied contract address is registered.\\r\\n     * @param id The identifier of the contract\\r\\n     * @param oldAddress The address of the old contract\\r\\n     * @param newAddress The address of the new contract\\r\\n     */\\r\\n    event AddressSet(\\r\\n        bytes32 indexed id,\\r\\n        address indexed oldAddress,\\r\\n        address indexed newAddress\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the implementation of the proxy registered with id is updated\\r\\n     * @param id The identifier of the contract\\r\\n     * @param proxyAddress The address of the proxy contract\\r\\n     * @param oldImplementationAddress The address of the old implementation contract\\r\\n     * @param newImplementationAddress The address of the new implementation contract\\r\\n     */\\r\\n    event AddressSetAsProxy(\\r\\n        bytes32 indexed id,\\r\\n        address indexed proxyAddress,\\r\\n        address oldImplementationAddress,\\r\\n        address indexed newImplementationAddress\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the id of the Aave market to which this contract points to.\\r\\n     * @return The market id\\r\\n     **/\\r\\n    function getMarketId() external view returns (string memory);\\r\\n\\r\\n    /**\\r\\n     * @notice Associates an id with a specific PoolAddressesProvider.\\r\\n     * @dev This can be used to create an onchain registry of PoolAddressesProviders to\\r\\n     * identify and validate multiple Aave markets.\\r\\n     * @param newMarketId The market id\\r\\n     */\\r\\n    function setMarketId(string calldata newMarketId) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Returns an address by its identifier.\\r\\n     * @dev The returned address might be an EOA or a contract, potentially proxied\\r\\n     * @dev It returns ZERO if there is no registered address with the given id\\r\\n     * @param id The id\\r\\n     * @return The address of the registered for the specified id\\r\\n     */\\r\\n    function getAddress(bytes32 id) external view returns (address);\\r\\n\\r\\n    /**\\r\\n     * @notice General function to update the implementation of a proxy registered with\\r\\n     * certain `id`. If there is no proxy registered, it will instantiate one and\\r\\n     * set as implementation the `newImplementationAddress`.\\r\\n     * @dev IMPORTANT Use this function carefully, only for ids that don't have an explicit\\r\\n     * setter function, in order to avoid unexpected consequences\\r\\n     * @param id The id\\r\\n     * @param newImplementationAddress The address of the new implementation\\r\\n     */\\r\\n    function setAddressAsProxy(bytes32 id, address newImplementationAddress)\\r\\n        external;\\r\\n\\r\\n    /**\\r\\n     * @notice Sets an address for an id replacing the address saved in the addresses map.\\r\\n     * @dev IMPORTANT Use this function carefully, as it will do a hard replacement\\r\\n     * @param id The id\\r\\n     * @param newAddress The address to set\\r\\n     */\\r\\n    function setAddress(bytes32 id, address newAddress) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the address of the Pool proxy.\\r\\n     * @return The Pool proxy address\\r\\n     **/\\r\\n    function getPool() external view returns (address);\\r\\n\\r\\n    /**\\r\\n     * @notice Updates the implementation of the Pool, or creates a proxy\\r\\n     * setting the new `pool` implementation when the function is called for the first time.\\r\\n     * @param newPoolImpl The new Pool implementation\\r\\n     **/\\r\\n    function setPoolImpl(address newPoolImpl) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the address of the PoolConfigurator proxy.\\r\\n     * @return The PoolConfigurator proxy address\\r\\n     **/\\r\\n    function getPoolConfigurator() external view returns (address);\\r\\n\\r\\n    /**\\r\\n     * @notice Updates the implementation of the PoolConfigurator, or creates a proxy\\r\\n     * setting the new `PoolConfigurator` implementation when the function is called for the first time.\\r\\n     * @param newPoolConfiguratorImpl The new PoolConfigurator implementation\\r\\n     **/\\r\\n    function setPoolConfiguratorImpl(address newPoolConfiguratorImpl) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the address of the price oracle.\\r\\n     * @return The address of the PriceOracle\\r\\n     */\\r\\n    function getPriceOracle() external view returns (address);\\r\\n\\r\\n    /**\\r\\n     * @notice Updates the address of the price oracle.\\r\\n     * @param newPriceOracle The address of the new PriceOracle\\r\\n     */\\r\\n    function setPriceOracle(address newPriceOracle) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the address of the ACL manager.\\r\\n     * @return The address of the ACLManager\\r\\n     */\\r\\n    function getACLManager() external view returns (address);\\r\\n\\r\\n    /**\\r\\n     * @notice Updates the address of the ACL manager.\\r\\n     * @param newAclManager The address of the new ACLManager\\r\\n     **/\\r\\n    function setACLManager(address newAclManager) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the address of the ACL admin.\\r\\n     * @return The address of the ACL admin\\r\\n     */\\r\\n    function getACLAdmin() external view returns (address);\\r\\n\\r\\n    /**\\r\\n     * @notice Updates the address of the ACL admin.\\r\\n     * @param newAclAdmin The address of the new ACL admin\\r\\n     */\\r\\n    function setACLAdmin(address newAclAdmin) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the address of the price oracle sentinel.\\r\\n     * @return The address of the PriceOracleSentinel\\r\\n     */\\r\\n    function getPriceOracleSentinel() external view returns (address);\\r\\n\\r\\n    /**\\r\\n     * @notice Updates the address of the price oracle sentinel.\\r\\n     * @param newPriceOracleSentinel The address of the new PriceOracleSentinel\\r\\n     **/\\r\\n    function setPriceOracleSentinel(address newPriceOracleSentinel) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the address of the data provider.\\r\\n     * @return The address of the DataProvider\\r\\n     */\\r\\n    function getPoolDataProvider() external view returns (address);\\r\\n\\r\\n    /**\\r\\n     * @notice Updates the address of the data provider.\\r\\n     * @param newDataProvider The address of the new DataProvider\\r\\n     **/\\r\\n    function setPoolDataProvider(address newDataProvider) external;\\r\\n}\\r\\n\",\"keccak256\":\"0xb6cb01954a8fb874975bc5552ff83664fcca355f470db97434674a2f8443f27f\",\"license\":\"AGPL-3.0\"},\"contracts/interface/IWooshCore.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.10;\\r\\n\\r\\ninterface IWooshCore {\\r\\n    event StartLoaning(\\r\\n        address indexed user,\\r\\n        address indexed token,\\r\\n        uint256 amount\\r\\n    );\\r\\n    event StopLoaning(\\r\\n        address indexed user,\\r\\n        address indexed token,\\r\\n        uint256 amount\\r\\n    );\\r\\n\\r\\n    function startloanDAI() external;\\r\\n\\r\\n    function stopLoanDAI() external;\\r\\n}\\r\\n\",\"keccak256\":\"0xf559a19d423c5b29709cec961103e12de1d1957f7cd1272fa789e1c98cb50934\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x6080604052600080546001600160a01b0319908116736c9fb0d5bd9429eb9cd96b85b81d872281771e6b17909155600180548216739a753f0f7886c9fbf63cf59d0d4423c5eface95b1790556002805490911673dd4f3ee61466c4158d394d57f3d4c397e91fbc5117905534801561007657600080fd5b50610373806100866000396000f3fe608060405234801561001057600080fd5b50600436106100575760003560e01c806308a016751461005c57806339ec407b1461008b57806358199b051461009e578063e0bab4c4146100a8578063fa717260146100bb575b600080fd5b60005461006f906001600160a01b031681565b6040516001600160a01b03909116815260200160405180910390f35b60025461006f906001600160a01b031681565b6100a66100c3565b005b60015461006f906001600160a01b031681565b6100a66101f4565b6001546040516370a0823160e01b81523360048201526000916001600160a01b0316906370a0823190602401602060405180830381865afa15801561010c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101309190610324565b6000805460015460405163617ba03760e01b81526001600160a01b039182166004820152602481018590523360448201526064810193909352929350919091169063617ba03790608401600060405180830381600087803b15801561019457600080fd5b505af11580156101a8573d6000803e3d6000fd5b50506001546040518481526001600160a01b0390911692503391507f46588cb4de245029a50c752511af49dc437c8e382c1ea925b4901158b9a96d11906020015b60405180910390a350565b6002546040516370a0823160e01b81523360048201526000916001600160a01b0316906370a0823190602401602060405180830381865afa15801561023d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102619190610324565b600054600154604051631a4ca37b60e21b81526001600160a01b0391821660048201526024810184905233604482015292935016906369328dec906064016020604051808303816000875af11580156102be573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102e29190610324565b506001546040518281526001600160a01b039091169033907fb68a3d413f2e3a1fbd2572c2be4936c3772f3f7c726fae5850c760a2d1789601906020016101e9565b60006020828403121561033657600080fd5b505191905056fea264697066735822122079362f66bc808b8f8cf1325df3d28c0b2cb547118674f12fab3ec73144af296c64736f6c634300080a0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100575760003560e01c806308a016751461005c57806339ec407b1461008b57806358199b051461009e578063e0bab4c4146100a8578063fa717260146100bb575b600080fd5b60005461006f906001600160a01b031681565b6040516001600160a01b03909116815260200160405180910390f35b60025461006f906001600160a01b031681565b6100a66100c3565b005b60015461006f906001600160a01b031681565b6100a66101f4565b6001546040516370a0823160e01b81523360048201526000916001600160a01b0316906370a0823190602401602060405180830381865afa15801561010c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101309190610324565b6000805460015460405163617ba03760e01b81526001600160a01b039182166004820152602481018590523360448201526064810193909352929350919091169063617ba03790608401600060405180830381600087803b15801561019457600080fd5b505af11580156101a8573d6000803e3d6000fd5b50506001546040518481526001600160a01b0390911692503391507f46588cb4de245029a50c752511af49dc437c8e382c1ea925b4901158b9a96d11906020015b60405180910390a350565b6002546040516370a0823160e01b81523360048201526000916001600160a01b0316906370a0823190602401602060405180830381865afa15801561023d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102619190610324565b600054600154604051631a4ca37b60e21b81526001600160a01b0391821660048201526024810184905233604482015292935016906369328dec906064016020604051808303816000875af11580156102be573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102e29190610324565b506001546040518281526001600160a01b039091169033907fb68a3d413f2e3a1fbd2572c2be4936c3772f3f7c726fae5850c760a2d1789601906020016101e9565b60006020828403121561033657600080fd5b505191905056fea264697066735822122079362f66bc808b8f8cf1325df3d28c0b2cb547118674f12fab3ec73144af296c64736f6c634300080a0033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "startloanDAI()": {
        "notice": "Deposit DAI into AAVE"
      },
      "stopLoanDAI()": {
        "notice": "Withdraw DAI from AAVE"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 90,
        "contract": "contracts/WooshCore.sol:WooshCore",
        "label": "AAVE_POOL",
        "offset": 0,
        "slot": "0",
        "type": "t_contract(IPool)1167"
      },
      {
        "astId": 96,
        "contract": "contracts/WooshCore.sol:WooshCore",
        "label": "DAI",
        "offset": 0,
        "slot": "1",
        "type": "t_contract(IERC20)77"
      },
      {
        "astId": 102,
        "contract": "contracts/WooshCore.sol:WooshCore",
        "label": "ADAI",
        "offset": 0,
        "slot": "2",
        "type": "t_contract(IERC20)77"
      }
    ],
    "types": {
      "t_contract(IERC20)77": {
        "encoding": "inplace",
        "label": "contract IERC20",
        "numberOfBytes": "20"
      },
      "t_contract(IPool)1167": {
        "encoding": "inplace",
        "label": "contract IPool",
        "numberOfBytes": "20"
      }
    }
  }
}